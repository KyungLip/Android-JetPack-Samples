# 视图绑定的作用

    减少样板代码 findViewById

# 如何使用

## 在需要开启视图绑定Module的build.gradle，android{}中配置如下：

```
    buildFeatures {
        viewBinding true
    }
```

    在开启视图绑定功能以后，系统会为该Module中每个xml布局文件生成绑定类。每个绑定类均包含根视图以及具有ID的视图的引用。

    用activity_binding_demo.xml布局文件来举例

```
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".binding.BindingDemoActivity">

    <EditText
        android:id="@+id/tv_title"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello World"
        app:layout_constraintBottom_toTopOf="parent"
        app:layout_constraintEnd_toStartOf="parent"
        tools:ignore="ViewBindingType"
        tools:viewBindingType="android.widget.TextView" />
</androidx.constraintlayout.widget.ConstraintLayout>
```

### 系统生成的绑定类名称

    布局文件名称转换为驼峰式大小写末尾+Binding
    例：activity_binding_demo.xml->ActivityBindingDemoBinding

### 绑定类位置

    /build/generated/data_binding_base_class_source_out

### 设置布局文件是否生成绑定类

    tools:viewBindingIgnore="true"
    添加到布局文件的根视图中，用于设置是否生成绑定类。

### 设置生成的类型

    tools:viewBindingType="android.widget.TextView"

    使用条件：
    1.必须继承android.view.View。
    2.必须是放置它的标签类型的超类。

```
    <EditText
    android:id="@+id/tv_title"
    tools:viewBindingType="android.widget.TextView"
    .../>
    <TextView android:id="@+id/tv_title"
    tools:viewBindingType="android.widget.TextView"
    .../>
```

这样在绑定类中生成的tv_title就是TextView类型，而不是EditText类型。

### 控件名称

      布局文件中控件会转化为绑定类的成员变量，控件名称由布局文件中控件ID转化为驼峰大小写形式。
      例:tv_title->tvTitle

## 在Activity中使用

        1.创建绑定类的实例。
         有三种方式：
            1.1 inflate(@NonNull LayoutInflater inflater)
            1.2 inflate(@NonNull LayoutInflater inflater,@Nullable ViewGroup parent, boolean attachToParent) 
            1.3 bind(@NonNull View rootView)
        2.获取根视图的引用，通过绑定类getRoot或者root。
        3.调用setContentView设置view。

```
class BindingDemoActivity : AppCompatActivity() {
    private lateinit var binding: ActivityBindingDemoBinding
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
//        setContentView(R.layout.activity_binding_demo)
        //1：创建绑定类的实例
        //1.1
        binding = ActivityBindingDemoBinding.inflate(layoutInflater)
//        //1.2
//        binding = ActivityBindingDemoBinding.inflate(layoutInflater, null, false)
//        //1.3
//        val rootVIew = layoutInflater.inflate(R.layout.activity_binding_demo, null, false)
//        binding = ActivityBindingDemoBinding.bind(rootVIew)
        
        //2：获取根视图的引用
        val rootView = binding.root
        //3:调用setContentView()
        setContentView(rootView)
        
        //使用控件
        binding.tvTitle.setOnClickListener {
            
        }
    }
}
```

## 在Fragment中使用

        1.创建绑定类的实例。
         有三种方式：
            1.1 inflate(@NonNull LayoutInflater inflater)
            1.2 inflate(@NonNull LayoutInflater inflater,@Nullable ViewGroup parent, boolean attachToParent) 
            1.3 bind(@NonNull View rootView)
        2.返回根视图的引用，通过绑定类getRoot或者root。

```
class BindingDemoFragment : Fragment() {
    private lateinit var mBinding: FragmentBindingDemoBinding
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        //1：创建绑定类的实例
//        //1.1
//        mBinding = FragmentBindingDemoBinding.inflate(layoutInflater)
        //1.2
        mBinding = FragmentBindingDemoBinding.inflate(layoutInflater, container, false)
//        //1.3
//        val rootVIew = layoutInflater.inflate(R.layout.fragment_binding_demo, null, false)
//        mBinding = FragmentBindingDemoBinding.bind(rootVIew)

        //2：返回根视图
        return mBinding.root
    }
}
```

## 在自定义View中使用

```
class CustomBindView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet?,
    defStyleAttr: Int = 0,
    defStyleRes: Int = 0
) :
    ConstraintLayout(context, attrs, defStyleAttr, defStyleRes) {
    private var viewBinding: LayoutCustomBindingViewBinding

    init {
        //1：创建绑定类的实例
        viewBinding = LayoutCustomBindingViewBinding.inflate(LayoutInflater.from(context))
//        viewBinding= LayoutCustomBindingViewBinding.inflate(LayoutInflater.from(context),this,true)
//        inflate(context, R.layout.layout_custom_binding_view, this)
//        viewBinding= LayoutCustomBindingViewBinding.bind(this)
    }
}
```

# 原理

    系统自动生成的绑定类

``` 
// Generated by view binder compiler. Do not edit!
package com.jetpack.samples.databinding;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.constraintlayout.widget.ConstraintLayout;
import androidx.viewbinding.ViewBinding;
import androidx.viewbinding.ViewBindings;
import com.jetpack.samples.R;
import java.lang.NullPointerException;
import java.lang.Override;
import java.lang.String;

public final class ActivityBindingDemoBinding implements ViewBinding {
  @NonNull
  private final ConstraintLayout rootView;

  @NonNull
  public final TextView tvTitle;

  private ActivityBindingDemoBinding(@NonNull ConstraintLayout rootView,
      @NonNull TextView tvTitle) {
    this.rootView = rootView;
    this.tvTitle = tvTitle;
  }

  @Override
  @NonNull
  public ConstraintLayout getRoot() {
    return rootView;
  }

  @NonNull
  public static ActivityBindingDemoBinding inflate(@NonNull LayoutInflater inflater) {
    return inflate(inflater, null, false);
  }

  @NonNull
  public static ActivityBindingDemoBinding inflate(@NonNull LayoutInflater inflater,
      @Nullable ViewGroup parent, boolean attachToParent) {
    View root = inflater.inflate(R.layout.activity_binding_demo, parent, false);
    if (attachToParent) {
      parent.addView(root);
    }
    return bind(root);
  }

  @NonNull
  public static ActivityBindingDemoBinding bind(@NonNull View rootView) {
    // The body of this method is generated in a way you would not otherwise write.
    // This is done to optimize the compiled bytecode for size and performance.
    int id;
    missingId: {
      id = R.id.tv_title;
      TextView tvTitle = ViewBindings.findChildViewById(rootView, id);
      if (tvTitle == null) {
        break missingId;
      }

      return new ActivityBindingDemoBinding((ConstraintLayout) rootView, tvTitle);
    }
    String missingId = rootView.getResources().getResourceName(id);
    throw new NullPointerException("Missing required view with ID: ".concat(missingId));
  }
}
```

    实现的ViewBinding接口：

``` 
public interface ViewBinding {
    /**
     * Returns the outermost {@link View} in the associated layout file. If this binding is for a
     * {@code <merge>} layout, this will return the first view inside of the merge tag.
     */
    @NonNull
    View getRoot();
}
```

实际上就是通过自动生成的绑定类，替我我们做了findViewById的操作。绑定类提供了三个静态防范，两个inflate,一个bind，最终都是调用到bind方法行。 在bind方法中
通过ViewBindings工具类使用循环遍历的方式找到我们在布局文件中对应的id控件，最后创建绑定类并把跟布局以及找到的控件作为构造函数传入。 Fragment以及自定义中同理。